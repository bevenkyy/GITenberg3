#!/usr/bin/env bash
#
# fff - fucking fast file-manager.

get_os() {
    # Figure out the current operating system to set
    # some specific variables.
    case "$OSTYPE" in
        # Mac OS X / macOS.
        darwin*)
            opener="open"
            file_flags="bIL"
        ;;

        haiku)
            opener="open"
        ;;
    esac
}

clear_screen() {
    # '\e[?25l': Hide the cursor.
    # '\e[?7l':  Disable line wrapping.
    # '\e[2J':   Clear the screen.
    # '\e[1;Nr': Limit scrolling to scrolling area.
    printf '\e[?25l\e[?7l\e[2J\e[1;%sr' "$max_items"
}

get_term_size() {
    # Get terminal size ('stty' is POSIX and always available).
    # This can't be done reliably in pure BASH.
    read -r LINES _ < <(stty size)

    # Max list items that fit in the scroll area.
    ((max_items=LINES-3))
}

status_line() {
    # '\e[s':      Save the current cursor position.
    # '\e[%sH':    Move cursor to bottom of the terminal.
    # '\e[A':      Move cursor up one to leave room for cmd-line.
    # '\e[30;41m': Set foreground and background colors.
    # '\e[K':      Clear to end of line (set background color to whole line).
    # '\e[m':      Reset text formatting.
    # '\e[u':      Restore cursor to saved position.
    printf '\e[s\e[%sH\e[A\e[30;41m%s\e[K\e[m\e[u' \
           "$LINES" "(${scroll:=0}/$((${#list[@]}-1))) ${PWD:-/}"
}

read_dir() {
    # Read a directory to an array and sort it directories first.
    dirs=(); files=()

    for item in "$PWD"/*; do
        [[ -d $item ]] && dirs+=("$item") || files+=("$item")
    done

    list=("${dirs[@]}" "${files[@]}")

    # Indicate that the directory is empty.
    # If the glob 'PWD/*' fails it'll set the array to a literal '*'.
    [[ ${list[0]} == "${PWD}/*" ]] &&
        list[0]="empty"
}

format_dir() {
    # Format the list item and print it.
    (($1 == scroll)) &&
        local format+='\e[7m'

    [[ -d ${list[$1]} ]] && {
        local format+='\e[1;32m'
        local suffix=/
    }

    printf '%b%s\e[m\r' "$format" "${list[$1]##*/}${suffix}"
}

print_dir() {
    # Print the max directory items that fit in the scroll area.

    # Window resize handling.
    # If the entire list fits in the scroll area, move cursor to top.
    ((${#list[@]} < max_items)) && scroll=0

    # 'i=scroll':         Print list items from scroll position.
    # 'max_items+scroll': Print list items up to max_items+scroll_position.
    #
    # '\e[1B': Move cursor down after print.
    #          Prevents issues with lines being eaten by the scroll area.
    # '\e[H':  Send cursor back home (0,0).
    for ((i=scroll;i<max_items+scroll;i++)); {
        format_dir "$i"
        printf '\e[1B'
    }
    printf '\e[H'
}

open() {
    # Open directories and files.
    if [[ -d $1/ ]]; then
        PWD="$1"
        read_dir
        clear_screen
        scroll=0
        print_dir

    elif [[ -f $1 ]]; then
        # Figure out what kind of file we're working with.
        mime_type="$(file "-${file_flags:-biL}" "$1")"

        # Open all text-based files in '$EDITOR'.
        # Everything else goes through 'xdg-open'/'open'.
        case "$mime_type" in
            text/*|*x-empty*|*json*)
                "${EDITOR:-vi}" "$1"

                # Clear the screen afterwards to re-set TUI settings.
                clear_screen
                print_dir
            ;;

            *)
                # 'nohup':  Make the process immune to hangups.
                # '&':      Send it to the background.
                # 'disown': Detach it from the shell.
                nohup "${FFF_OPENER:-${opener:-xdg-open}}" "$1" &>/dev/null &
                disown
            ;;
        esac
    fi
}

key() {
    case "$1" in
        # Open list item.
        # 'C' is what BASH sees when the right arrow is pressed ('\e[C').
        # '' is what bash sees when the enter/return key is pressed.
        C|l|'') open "${list[scroll]}" ;;

        # Go to the parent directory.
        # 'D' is what BASH sees when the left arrow is pressed ('\e[D').
        D|h) open "${PWD%/*}" ;;

        # Scroll down.
        # 'B' is what BASH sees when the down arrow is pressed ('\e[B').
        B|j)
            # '\eD': Move cursor down. If cursor hits the bottom margin of
            #        the scroll area, scroll the window down.
            ((scroll < ${#list[@]}-1)) && {
                ((scroll++))
                format_dir "$((scroll-1))"
                printf '\eD'
                format_dir "$scroll"
            }
        ;;

        # Scroll up.
        # 'A' is what BASH sees when the down arrow is pressed ('\e[A').
        A|k)
            # '\eM': Move cursor up. If cursor hits the top margin of
            #        the scroll area, scroll the window down.
            ((scroll > 0)) && {
                ((scroll--))
                format_dir "$((scroll+1))"
                printf '\eM'
                format_dir "$scroll"
            }
        ;;

        # Go to top.
        g) scroll=0; clear_screen; print_dir ;;

        q) exit ;;
    esac
}

main() {
    # Handle a directory as the first argument.
    # 'pushd' is a cheap way of finding the full path to a directory.
    # It handles relative paths as well as '../../../'.
    #
    # '||:': Do nothing if 'pushd' fails. We don't care.
    pushd "$1" &>/dev/null ||:

    get_os
    get_term_size
    clear_screen

    # Trap the exit signal (we need to reset the terminal to a useable state.)
    # '\e[?7h':  Re-enable line wrapping.
    # '\e[?25h': Unhide the cursor.
    # '\e[2J':   Clear the terminal.
    # '\e[;r':   Set the scroll region to its default value.
    trap 'printf "\e[?7h\e[?25h\e[2J\e[;r"' EXIT

    # Trap the window resize signal (handle window resize events).
    trap 'get_term_size; clear_screen; print_dir; status_line' WINCH

    read_dir
    print_dir

    for ((;;)); {
        status_line
        read -rsn 1 && key "$REPLY"
    }
}

main "$@"

#!/usr/bin/env bash
#
# fuck

# DL—Delete Line
# IL—Insert Line
# NEL—Next Line
# SD—Pan Up
# SU—Pan Down
# SGR—Select Graphic Rendition
# SRM—Local Echo: Send/Receive Mode
# VPA—Vertical Line Position Absolute
# DECVCCM—Vertical Cursor-Coupling Mode

clear_screen() {
    # '\e[?25l': Hide the cursor.
    # '\e[?7l':  Disable line wrapping.
    # '\e[2J':   Clear the screen.
    # '\e[1;Nr': Limit scrolling to scrolling area (LINES-3).
    printf '\e[?25l\e[?7l\e[2J\e[1;%sr' "$((LINES-3))"

    # Move cursor to top on resize.
    # TODO: Proper resize handling (keep position.)
    scroll=0
}

get_term_size() {
    # Get terminal size ('stty' is POSIX and always available).
    # This can't be done reliably in pure BASH.
    read -r LINES _ < <(stty size)
}

status_line() {
    # '\e[s':      Save the current cursor position.
    # '\e[%sH':    Move cursor to bottom of the terminal.
    # '\e[A':      Move cursor up one to leave room for cmd-line.
    # '\e[30;41m': Set foreground and background colors.
    # '\e[K':      Clear to end of line (set background color to whole line).
    # '\e[m':      Reset text formatting.
    # '\e[u':      Restore cursor to saved position.
    printf '\e[s\e[%sH\e[A\e[30;41m%s\e[K\e[m\e[u' "$LINES" "$PWD"
}

read_dir() {
    # Read a directory to an array and sort it directories first.
    dirs=(); files=()

    for item in "$PWD"/*; do
        [[ -d $item ]] && dirs+=("$item") || files+=("$item")
    done

    list=("${dirs[@]}" "${files[@]}")

    # Indicate that the directory is empty.
    [[ -z ${list[0]} ]] &&
        list[0]="empty"
}

format_dir() {
    # Format the list item and print it.
    (($1 == scroll)) &&
        local format+='\e[7m'

    [[ -d ${list[$1]} ]] && {
        local format+='\e[1;32m'
        local suffix=/
    }

    printf '%b%s\e[m\r' "$format" "${list[$1]##*/}${suffix}"
}

print_dir() {
    # Print from beginning of list to LINES-status_bar.
    # '\e[1B': Move cursor down after print.
    #          Prevents issues with lines being eaten by the scroll area.
    # '\e[H':  Send cursor back home (0,0).
    for ((i=0;i<LINES-3;i++)); {
        format_dir "$i"
        printf '\e[1B'
    }
    printf '\e[H'
}

key() {
    case "$1" in
        # Scroll down.
        # 'B' is what BASH sees when the down arrow is pressed ('\e[B').
        B|j)
            # '\eD': Move cursor down. If cursor hits the bottom margin of
            #        the scroll area, scroll the window down.
            ((scroll < ${#list[@]}-1)) && {
                ((scroll++))
                format_dir "$((scroll-1))"
                printf '\eD'
                format_dir "$scroll"
            }
        ;;

        # Scroll up.
        # 'A' is what BASH sees when the down arrow is pressed ('\e[A').
        A|k)
            # '\eM': Move cursor up. If cursor hits the top margin of
            #        the scroll area, scroll the window down.
            ((scroll > 0)) && {
                ((scroll--))
                format_dir "$((scroll+1))"
                printf '\eM'
                format_dir "$scroll"
            }
        ;;
    esac
}

main() {
    # Handle a directory as the first argument.
    # 'pushd' is a cheap way of finding the full path to a directory.
    # It handles relative paths as well as '../../../'.
    #
    # '||:': Do nothing if 'pushd' fails. We don't care.
    pushd "$1" &>/dev/null ||:

    get_term_size
    clear_screen

    # Trap the exit signal (we need to reset the terminal to a useable state.)
    # '\e[?7h':  Re-enable line wrapping.
    # '\e[?25h': Unhide the cursor.
    # '\e[2J':   Clear the terminal.
    # '\e[;r':   Set the scroll region to its default value.
    trap 'printf "\e[?7h\e[?25h\e[2J\e[;r"' EXIT

    # Trap the window resize signal (handle window resize events).
    trap 'get_term_size; clear_screen; print_dir; status_line' WINCH

    read_dir
    print_dir

    for ((;;)); {
        status_line
        read -rsn 1 && key "$REPLY"
    }
}

main "$@"

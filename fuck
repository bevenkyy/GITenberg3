#!/usr/bin/env bash
#
# fff - fucking fast file-manager.

get_os() {
    # Figure out the current operating system to set some specific variables.
    # '$OSTYPE' typically stores the name of the OS kernel.
    case "$OSTYPE" in
        # Mac OS X / macOS.
        darwin*)
            opener="open"
            file_flags="bIL"
        ;;

        haiku)
            opener="open"
        ;;
    esac
}

clear_screen() {
    # Setup the terminal for the TUI.
    # '\e[?7l':  Disable line wrapping.
    # '\e[?25l': Hide the cursor.
    # '\e[2J':   Clear the screen.
    # '\e[1;Nr': Limit scrolling to scrolling area.
    #            Also sets cursor to (0,0).
    printf '\e[?7l\e[?25l\e[2J\e[1;%sr' "$max_items"
}

reset_terminal() {
    # Reset the terminal to a useable state (undo all changes).
    # '\e[?7h':  Re-enable line wrapping.
    # '\e[?25h': Unhide the cursor.
    # '\e[2J':   Clear the terminal.
    # '\e[;r':   Set the scroll region to its default value.
    #            Also sets cursor to (0,0).
    printf '\e[?7h\e[?25h\e[2J\e[;r'
}

get_term_size() {
    # Get terminal size ('stty' is POSIX and always available).
    # This can't be done reliably in pure BASH.
    read -r LINES _ < <(stty size)

    # Max list items that fit in the scroll area.
    ((max_items=LINES-3))
}

status_line() {
    # '\e[s':      Save the current cursor position.
    # '\e[%sH':    Move cursor to bottom of the terminal.
    # '\e[A':      Move cursor up one to leave room for cmd-line.
    # '\e[30;41m': Set foreground and background colors.
    # '\e[K':      Clear to end of line (set background color to whole line).
    # '\e[m':      Reset text formatting.
    # '\e[u':      Restore cursor to saved position.
    printf '\e[s\e[%sH\e[A\e[30;41m%s\e[K\e[m\e[u' \
           "$LINES" "(${scroll:=0}/$((list_total-1))) ${PWD:-/}"
}

read_dir() {
    # Read a directory to an array and sort it directories first.
    dirs=(); files=()

    for item in "$PWD"/*; do
        [[ -d $item ]] && dirs+=("$item") || files+=("$item")
    done

    list=("${dirs[@]}" "${files[@]}")
    list_total="${#list[@]}"

    # Indicate that the directory is empty.
    # If the glob 'PWD/*' fails it'll set the array to a literal '*'.
    [[ ${list[0]} == "${PWD}/*" ]] &&
        list[0]="empty"
}

format_dir() {
    # Format the list item and print it.
    (($1 == scroll)) &&
        local format+='\e[7m'

    [[ -d ${list[$1]} ]] && {
        local format+='\e[1;32m'
        local suffix=/
    }

    printf '%b%s\e[m\r' "$format" "${list[$1]##*/}${suffix}"
}

print_dir() {
    # Print the max directory items that fit in the scroll area.

    # If the entire list fits in the scroll area, move cursor to top.
    ((list_total < max_items)) &&
        ((scroll=0))

    # If the cursor is near the bottom of the list, display the entire bottom.
    ((list_total - scroll < max_items)) &&
        ((scroll=list_total-max_items))

    # 'i=scroll':         Print list items from scroll position.
    # 'max_items+scroll': Print list items up to max_items+scroll_position.
    #
    # '\e[1B': Move cursor down after print.
    #          Prevents issues with lines being eaten by the scroll area.
    # '\e[H':  Send cursor back home (0,0).
    for ((i=scroll;i<max_items+scroll;i++)); {
        format_dir "$i"
        printf '\e[1B'
    }
    printf '\e[H'
}

redraw() {
    # Redraw the current window.
    # If 'full' is passed, re-fetch the directory list.
    [[ $1 == full ]] && {
        read_dir
        scroll=0
    }

    clear_screen
    print_dir
}

open() {
    # Open directories and files.
    if [[ -d $1/ ]]; then
        PWD="$1"
        redraw full

    elif [[ -f $1 ]]; then
        # Figure out what kind of file we're working with.
        mime_type="$(file "-${file_flags:-biL}" "$1")"

        # Open all text-based files in '$EDITOR'.
        # Everything else goes through 'xdg-open'/'open'.
        case "$mime_type" in
            text/*|*x-empty*|*json*)
                "${EDITOR:-vi}" "$1"

                # Redraw the screen afterwards to re-set TUI settings.
                redraw
            ;;

            *)
                # 'nohup':  Make the process immune to hangups.
                # '&':      Send it to the background.
                # 'disown': Detach it from the shell.
                nohup "${FFF_OPENER:-${opener:-xdg-open}}" "$1" &>/dev/null &
                disown
            ;;
        esac
    fi
}

key() {
    case "$1" in
        # Open list item.
        # 'C' is what BASH sees when the right arrow is pressed ('\e[C').
        # '' is what bash sees when the enter/return key is pressed.
        C|l|'') open "${list[scroll]}" ;;

        # Go to the parent directory.
        # 'D' is what BASH sees when the left arrow is pressed ('\e[D').
        D|h) open "${PWD%/*}" ;;

        # Scroll down.
        # 'B' is what BASH sees when the down arrow is pressed ('\e[B').
        B|j)
            # '\eD': Move cursor down. If cursor hits the bottom margin of
            #        the scroll area, scroll the window down.
            ((scroll < list_total-1)) && {
                ((scroll++))
                format_dir "$((scroll-1))"
                printf '\eD'
                format_dir "$scroll"
            }
        ;;

        # Scroll up.
        # 'A' is what BASH sees when the down arrow is pressed ('\e[A').
        A|k)
            # '\eM': Move cursor up. If cursor hits the top margin of
            #        the scroll area, scroll the window down.
            ((scroll > 0)) && {
                ((scroll--))
                format_dir "$((scroll+1))"
                printf '\eM'
                format_dir "$scroll"
            }
        ;;

        # Go to top.
        g) ((scroll=0)); redraw ;;

        # Go to bottom.
        # TODO: Fix this.
        G) ((scroll=list_total-1)); redraw ;;

        # Show hidden files.
        .)
            # 'a=a>0?0:++a': Toggle between both values of 'shopt_flags'.
            shopt_flags=(u s)
            shopt -"${shopt_flags[((a=a>0?0:++a))]}" dotglob
            redraw full
        ;;

        # Spawn a shell.
        s)
            reset_terminal
            cd "$PWD" && "$SHELL"
            redraw
        ;;

        q) exit ;;
    esac
}

main() {
    # Handle a directory as the first argument.
    # 'pushd' is a cheap way of finding the full path to a directory.
    # It handles relative paths as well as '../../../'.
    #
    # '||:': Do nothing if 'pushd' fails. We don't care.
    pushd "$1" &>/dev/null ||:

    get_os
    get_term_size
    clear_screen

    # Trap the exit signal (we need to reset the terminal to a useable state.)
    # '\e[?7h':  Re-enable line wrapping.
    # '\e[?25h': Unhide the cursor.
    # '\e[2J':   Clear the terminal.
    # '\e[;r':   Set the scroll region to its default value.
    trap 'reset_terminal' EXIT

    # Trap the window resize signal (handle window resize events).
    trap 'get_term_size; redraw; status_line' WINCH

    read_dir
    print_dir

    for ((;;)); {
        status_line
        read -rsn 1 && key "$REPLY"
    }
}

main "$@"

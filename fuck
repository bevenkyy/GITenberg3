#!/usr/bin/env bash
#
# fff - fucking fast file-manager.

get_os() {
    # Figure out the current operating system to set some specific variables.
    # '$OSTYPE' typically stores the name of the OS kernel.
    case "$OSTYPE" in
        # Mac OS X / macOS.
        darwin*)
            opener="open"
            file_flags="bIL"
        ;;

        haiku)
            opener="open"
        ;;
    esac
}

clear_screen() {
    # Setup the terminal for the TUI.
    # '\e[?6h':  Restrict cursor to scrolling area.
    # '\e[?7l':  Disable line wrapping.
    # '\e[?25l': Hide the cursor.
    # '\e[2J':   Clear the screen.
    # '\e[1;Nr': Limit scrolling to scrolling area.
    #            Also sets cursor to (0,0).
    printf '\e[?6h\e[?7l\e[?25l\e[2J\e[1;%sr' "$max_items"
}

reset_terminal() {
    # Reset the terminal to a useable state (undo all changes).
    # '\e[?6l':  Unrestrict cursor movement (full window).
    # '\e[?7h':  Re-enable line wrapping.
    # '\e[?25h': Unhide the cursor.
    # '\e[2J':   Clear the terminal.
    # '\e[;r':   Set the scroll region to its default value.
    #            Also sets cursor to (0,0).
    printf '\e[?6l\e[?7h\e[?25h\e[2J\e[;r'
}

get_term_size() {
    # Get terminal size ('stty' is POSIX and always available).
    # This can't be done reliably in pure BASH.
    read -r LINES _ < <(stty size)

    # Max list items that fit in the scroll area.
    ((max_items=LINES-3))
}

status_line() {
    # '\e[s':      Save the current cursor position.
    # '\e[?6l':    Unrestrict cursor movement (full window).
    # '\e[%sH':    Move cursor to bottom of the terminal.
    # '\e[30;41m': Set foreground and background colors.
    # '\e[K':      Clear to end of line (set background color to whole line).
    # '\e[m':      Reset text formatting.
    # '\e[?6h':    Restrict cursor to scrolling area.
    # '\e[u':      Restore cursor to saved position.
    printf '\e[s\e[?6l\e[%sH\e[30;4%sm%s\e[K\e[7m\e[m\e[?6h\e[u' \
           "$((LINES-1))" \
           "${FFF_COL2:-1}" \
           "(${scroll:=0}/${list_total}) ${PWD:-/}"
}

read_dir() {
    # Read a directory to an array and sort it directories first.
    dirs=(); files=(); item_index=

    for item in "$PWD"/*; do
        if [[ -d $item ]]; then
            dirs+=("$item")
            ((item_index++))

            # Find the position of the child directory in the
            # parent directory list.
            [[ $item == "$previous_dir" ]] &&
                ((previous_index=item_index))
        else
            files+=("$item")
        fi
    done

    list=("${dirs[@]}" "${files[@]}")
    ((list_total=${#list[@]}-1))

    # Indicate that the directory is empty.
    # If the glob 'PWD/*' fails it'll set the array to a literal '*'.
    [[ ${list[0]} == "${PWD}/*" ]] &&
        list[0]="empty"
}

format_dir() {
    # Format the list item and print it.
    [[ -d ${list[$1]} ]] && {
        local format+="\\e[1;3${FFF_COL1:-2}m"
        local suffix=/
    }

    (($1 == scroll)) &&
        local format+="\\e[1;3${FFF_COL4:-6};7m"

    printf '%b%s\e[m\r' "$format" "${list[$1]##*/}${suffix}"
}

print_dir() {
    # Print the max directory items that fit in the scroll area.
    local scroll_start="$scroll"
    local scroll_new_pos

    # When going up the directory tree, place the cursor on the position
    # of the previous directory.
    ((find_previous == 1)) && {
        ((scroll_start=previous_index-1))
        ((scroll=scroll_start))

        # Clear the directory history. We're here now.
        previous_dir=
        find_previous=
    }

    # If the entire list fits in the scroll area, don't print from scroll
    # position. Print from the start of the list. Also keep the cursor at its
    # current location.
    if ((list_total < max_items)); then
        ((scroll_start=0))
        ((scroll_new_pos=scroll + 1))

    # If the cursor is near the bottom of the list, display the entire bottom.
    # Also keep the cursor at its current location.
    # 'scroll_new_pos' figures out which line number the cursor is on.
    elif ((list_total - scroll < max_items)); then
        ((scroll_start=list_total - max_items + 1))
        ((scroll_new_pos=max_items - (list_total-scroll)))
    fi

    # 'i=scroll':         Print list items from scroll position.
    # 'max_items+scroll': Print list items up to max_items+scroll_position.
    #
    # '\e[1B': Move cursor down after print.
    #          Prevents issues with lines being eaten by the scroll area.
    # '\e[H':  Send cursor back home (0,0).
    for ((i=scroll_start;i<max_items+scroll;i++)); {
        format_dir "$i"
        printf '\e[1B'
    }

    # Move the cursor to its new position if it changed.
    # If the variable 'scroll_new_pos' is empty, the cursor is moved to line '0'.
    printf '\e[%sH' "$scroll_new_pos"
}

redraw() {
    # Redraw the current window.
    # If 'full' is passed, re-fetch the directory list.
    [[ $1 == full ]] && {
        read_dir
        scroll=0
    }

    clear_screen
    print_dir
}

open() {
    # Open directories and files.
    if [[ -d $1/ ]]; then
        PWD="$1"
        redraw full

    elif [[ -f $1 ]]; then
        # Figure out what kind of file we're working with.
        mime_type="$(file "-${file_flags:-biL}" "$1")"

        # Open all text-based files in '$EDITOR'.
        # Everything else goes through 'xdg-open'/'open'.
        case "$mime_type" in
            text/*|*x-empty*|*json*)
                "${EDITOR:-vi}" "$1"

                # Redraw the screen afterwards to re-set TUI settings.
                redraw
            ;;

            *)
                # 'nohup':  Make the process immune to hangups.
                # '&':      Send it to the background.
                # 'disown': Detach it from the shell.
                nohup "${FFF_OPENER:-${opener:-xdg-open}}" "$1" &>/dev/null &
                disown
            ;;
        esac
    fi
}

key() {
    case "$1" in
        # Open list item.
        # 'C' is what BASH sees when the right arrow is pressed ('\e[C').
        # '' is what bash sees when the enter/return key is pressed.
        l|C|'')
            open "${list[scroll]}"
        ;;

        # Go to the parent directory.
        # 'D' is what BASH sees when the left arrow is pressed ('\e[D').
        # '\177' is what BASH sees when the backspace key is pressed.
        # '[[ $PWD ]]' If '$PWD' is empty we're at '/', do nothing.
        h|D|$'\177')
            previous_dir="$PWD"
            find_previous=1
            [[ $PWD ]] && open "${PWD%/*}"
        ;;

        # Scroll down.
        # 'B' is what BASH sees when the down arrow is pressed ('\e[B').
        B|j)
            # '\eD': Move cursor down. If cursor hits the bottom margin of
            #        the scroll area, scroll the window down.
            ((scroll < list_total)) && {
                ((scroll++))
                format_dir "$((scroll-1))"
                printf '\eD'
                format_dir "$scroll"
            }
        ;;

        # Scroll up.
        # 'A' is what BASH sees when the down arrow is pressed ('\e[A').
        A|k)
            # '\eM': Move cursor up. If cursor hits the top margin of
            #        the scroll area, scroll the window down.
            ((scroll > 0)) && {
                ((scroll--))
                format_dir "$((scroll+1))"
                printf '\eM'
                format_dir "$scroll"
            }
        ;;

        # Go to top.
        g) ((scroll=0)); redraw ;;

        # Go to bottom.
        G) ((scroll=list_total)); redraw ;;

        # Show hidden files.
        .)
            # 'a=a>0?0:++a': Toggle between both values of 'shopt_flags'.
            #                This also works for '3' or more values with
            #                some modification.
            shopt_flags=(u s)
            shopt -"${shopt_flags[((a=a>0?0:++a))]}" dotglob
            redraw full
        ;;

        # Spawn a shell.
        s)
            reset_terminal
            cd "$PWD" && "$SHELL"
            redraw
        ;;

        # Go to '$HOME'.
        \~) open ~ ;;

        q) exit ;;
    esac
}

main() {
    # Handle a directory as the first argument.
    # 'pushd' is a cheap way of finding the full path to a directory.
    # It updates the '$PWD' variable on successful execution.
    # It handles relative paths as well as '../../../'.
    #
    # '||:': Do nothing if 'pushd' fails. We don't care.
    pushd "$1" &>/dev/null ||:

    get_os
    get_term_size

    # Trap the exit signal (we need to reset the terminal to a useable state.)
    # See: 'help trap', 'trap -l'.
    trap 'reset_terminal' EXIT

    # Trap the window resize signal (handle window resize events).
    # See: 'help trap', 'trap -l'.
    trap 'get_term_size; redraw; status_line' WINCH

    redraw full

    # Vintage infinite loop.
    for ((;;)); {
        status_line
        read -rsn 1 && key "$REPLY"
    }
}

main "$@"
